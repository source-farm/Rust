#![allow(unused_variables)]
fn main() {
    // Структура данных Vec<T> из стандартной библиотеки позволяет хранить данные в куче в
    // непрерывном участке памяти. Все элементы вектора должны быть одно и того же типа.
    // Создать новый пустой вектор можно так:
    let v: Vec<i32> = Vec::new();

    // Т.к. мы не указали значения, из которых состоит вектор, то необходимо явно указывать тип
    // вектора - компилятору необходимо знать тип любой переменной. Для создания вектора, который
    // уже заполнен чем-либо можно воспользоваться макросом vec!:
    let v = vec![1, 2, 3];

    // Здесь мы не указали тип переменной, но Rust может сам его вывести с учётом того, что
    // целочисленные литералы имеют тип i32.

    // Данные в вектор можно добавить, например, с помощью метода push(добавление в конец):
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v.push(3);

    // Как и любая другая структура, вектор и всё его содержимое очищается при выходе из области
    // видимости:
    {
        let v = vec![1, 2, 3];
    } // v выходит из области видимости, а значит вектор будет очищен.

    // Доступ к значениям вектора можно получить либо по индексу в квадратных скобках либо передав
    // индекс методу get. Индекс начинается с 0:
    let v = vec![1, 2, 3, 4, 5];
    let third: &i32 = &v[2]; // Здесь необъязательно нужно явно указывать тип переменной third.
    println!("third: {}", third);

    match v.get(2) {
        Some(third) => println!("third: {}", third),
        None => println!("no third element"),
    }

    // Если в синтаксисе с квадратными скобками передать индекс, который выходит за границу
    // вектора, то на этапе выполнения будет паника.
    // Следующий код вызовет панику:
    // let does_not_exist = &v[42];

    // Метод get при получении индекса несуществующего в векторе элемента просто вернёт
    // None(вариант перечисления Option<T>):
    let does_not_exist = v.get(42);
    if does_not_exist == None {
        println!("does_not_exist: None");
    }

    // Нельзя добавлять элемент в вектор, если у нас есть ссылка на какой-либо элемент вектора(даже
    // неизменяемый).
    // Следующий код вызовет ошибку компиляции из-за ошибки заимствования: нельзя иметь изменяемую
    // ссылку, если в области видимости уже есть какая-либо другая ссылка.
    //
    //     let mut v = vec![1, 2, 3];
    //     let first = &v[0];
    //     v.push(4);
    //     println!("first: {}", first);

    // Пройтись по всем значениям вектора можно так:
    let v = vec![2, 3, 5];
    // Здесь i является неизменяемой ссылкой.
    for i in &v {
        println!("{}", i);
    }

    // Можно также воспользоваться и изменяемыми ссылками:
    let mut v = vec![2, 3, 5];
    for i in &mut v {
        *i += 40 // '*' - это оператор разыменовывания(dereference operator). Будет рассмотрен в
                 // главе 15.
    }
    println!("v[0]: {}", v[0]);

    // Для того чтобы в векторе можно было хранить значения разных типов можно воспользоваться
    // перечислением, у которого каждый вариант имеет определённый тип:
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(0),
        SpreadsheetCell::Float(1.23),
        SpreadsheetCell::Text(String::from("4")),
    ];

    // При таком подходе необходимо заранее знать типы всех значений, которые могут войти в вектор.
}
