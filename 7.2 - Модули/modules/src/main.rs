// Rust обладает свойством, которое часто называют "модульной системой", но оно само по себе
// состоит из нескольких свойств. Модули позволяют управляют областью видимости имён и доступом
// к этим именам. Кроме модулей мы здесь рассмотрим пути, use, pub, as и др. Начнём с модулей.

//--------------------------------------------------------------------------------
// Модули
//--------------------------------------------------------------------------------

// Модули позволяют организовать код в группы, по некоторому общему признаку. Пример модуля:

// После ключевого слова mod указывают название модуля.
mod animal {
    // Функция cat принадлежит модулю animal.
    fn cat() {
        // Тело функции.
    }
}

// Можно создавать иерархии модулей:
mod country {
    mod region {
        mod city {
            fn street() {
                // Тело функции
            }
        }
    }

    mod government {
        // Код модуля.
    }
}

// В предыдущей главе мы говорили, что файлы src/main.rs и src/lib.rs формируют так называемый
// корень крейта(crate root). Они его формируют по той причине, что из содержимого какого-либо
// из этих файлов состоит модуль по имени crate, который является корнем дерева модулей этого
// крейта. Для кода, приведённого выше, дерево модулей можно изобразить так:
//
//    crate
//      └──country
//            └──region
//            |     └──city
//            |
//            └──government
//
// Модуль crate создаётся неявно, но он, как мы уже говорили, находится в корне дерева модулей
// любого крейта.
// Это дерево модулей напоминает дерево папок в файловой системе и при работе с модулями такая
// аналогия является очень подходящей. Также как и в файловой системе для доступа к элементам
// внутри папок необходимо определять путь до них, то же самое делается и в дереве модулей.

// Ещё один пример дерева модулей:
mod sound {
    // В Rust модули также решают, что клиенты этого модуля могут использовать из того, что
    // определено внутри него. Для этого применяются следующие правила:
    //
    //     - все элементы(функции, методы, структуры, перечисления, модули и константы) внутри
    //       модуля по-умолчанию являются приватными(private).
    //
    //     - элемент можно сделать публичным с помощью ключевого слова pub.
    //
    //     - из текущего модуля нельзя обращаться к приватным элементам, определённым в его дочерних
    //       модулях.
    //
    //     - из текущего модуля можно обращаться к любому коду, который определён в родительских
    //       модулях или в этом же модуле.

    // Делаем модуль публичным. То что модуль становится публичным не означает, что всё его
    // содержимео тоже автоматически становится публичным.
    pub mod instrument {
        pub fn clarinet() {
            // Для доступа к родительскому модулю при использовании относительных путей можно
            // воспользоваться ключевым словом super(это напоминает доступ к родительской папке в
            // файловой системе через ..):
            super::breath_in();

            // Преимуществом относительных путей является то, что с ними легче проводить
            // перестраивания в иерархии модулей.
        }
    }

    fn breath_in() {
        // Тело функции.
    }
}

//--------------------------------------------------------------------------------
// pub с структурами и перечислениями
//--------------------------------------------------------------------------------

// Если структуру внутри модуля сделать публичной с помощью pub, то это не превращает её поля в
// публичные: для каждого поля нужно отдельно указывать является ли оно публичным:
mod plant {
    pub struct Vegetable {
        pub name: String,
        // Поле id является приватным.
        id: i32,
    }

    impl Vegetable {
        // Без этой ассоциированной функции мы вообще не сумели бы создать экземпляр Vegetable,
        // т.к. при создании экземпляра структуры необходимо явно указывать значения каждого поля,
        // а для поля id мы не можем это сделать, т.к. оно является приватным.
        pub fn new(name: &str) -> Vegetable {
            Vegetable {
                name: String::from(name),
                id: 1,
            }
        }
    }
}

// Для перечислений указание pub перед его определением превращает каждый вариант в публичный.
mod menu {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

fn main() {
    //--------------------------------------------------------------------------------
    // Пути
    //--------------------------------------------------------------------------------

    // Если мы хотим вызвать функцию внутри какого-либо модуля, то нам необходимо знать путь(path)
    // до неё. Существует два вида путей в Rust:
    //
    //     - абсолютный - начинается с корня крейта, используя название пакета, или с литерала
    //       crate.
    //
    //     - относительный - начинается с текущего модуля и использует self, super или
    //       идентификатор в текущем модуле.

    // Пример обращения к функции через путь:

    // Абсолютный путь.
    // Т.к. функция clarinet определена в том же крейте, что и функция main, то мы
    // можем обратиться к ней через абсолютный путь, который начинается с crate.
    // Рассмотрим более подробне почему мы смогли вызвать функцию clarinet(). Модуль sound является
    // приватным, но он определён в том же модуле crate, что и функция main, т.е. находится на
    // одном уровне дерева модулей с main. Поэтому из main можно обращаться к этому модулю. Модуль
    // instrument так же как и функция clarinet является публичным, а раз у нас есть доступ к
    // sound, значит есть доступ и к clarinet.
    crate::sound::instrument::clarinet();

    // Относительный путь.
    // Начинается с модуля sound, который находится на том же уровне в дереве модулей, что и функция
    // main.
    // Мы получили доступ к функции clarinet по тем же причинам, что описаны для случая
    // абсолютного пути, за исключением первого шага - относительные пути не начинаются с crate.
    sound::instrument::clarinet();

    //--------------------------------------------------------------------------------
    // pub с структурами и перечислениями
    //--------------------------------------------------------------------------------

    let mut v = plant::Vegetable::new("squash");
    v.name = String::from("butternut squash");
    println!("{} is delicious", v.name);

    // Будет ошибка компиляции. Поле id является приватным.
    // println!("The ID is {}", v.id);

    // Можно обращаться к вариантам перечисления, т.к. оно является публичным.
    let order1 = menu::Appetizer::Soup;
    let order2 = menu::Appetizer::Salad;
}
