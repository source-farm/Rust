// Rust обладает свойством, которое часто называют "модульной системой", но оно само по себе
// состоит из нескольких свойств. Модули позволяют управляют областью видимости имён и доступом
// к этим именам. Кроме модулей мы здесь рассмотрим пути, use, pub, as и др. Начнём с модулей.

//--------------------------------------------------------------------------------
// Модули
//--------------------------------------------------------------------------------

// Модули позволяют организовать код в группы, по некоторому общему признаку. Пример модуля:

// После ключевого слова mod указывают название модуля.
mod animal {
    // Функция cat принадлежит модулю animal.
    fn cat() {
        // Тело функции.
    }
}

// Можно создавать иерархии модулей:
mod country {
    mod region {
        mod city {
            fn street() {
                // Тело функции
            }
        }
    }

    mod government {
        // Код модуля.
    }
}

// В предыдущей главе мы говорили, что файлы src/main.rs и src/lib.rs формируют так называемый
// корень крейта(crate root). Они его формируют по той причине, что из содержимого какого-либо
// из этих файлов состоит модуль по имени crate, который является корнем дерева модулей этого
// крейта. Для кода, приведённого выше, дерево модулей можно изобразить так:
//
//    crate
//      └──country
//            └──region
//            |     └──city
//            |
//            └──government
//
// Модуль crate создаётся неявно, но он, как мы уже говорили, находится в корне дерева модулей
// любого крейта.
// Это дерево модулей напоминает дерево папок в файловой системе и при работе с модулями такая
// аналогия является очень подходящей. Также как и в файловой системе для доступа к элементам
// внутри папок необходимо определять путь до них, то же самое делается и в дереве модулей.

// Ещё один пример дерева модулей:
mod sound {
    // В Rust модули также решают, что клиенты этого модуля могут использовать из того, что
    // определено внутри него. Для этого применяются следующие правила:
    //
    //     - все элементы(функции, методы, структуры, перечисления, модули и константы) внутри
    //       модуля по-умолчанию являются приватными(private).
    //
    //     - элемент можно сделать публичным с помощью ключевого слова pub.
    //
    //     - из текущего модуля нельзя обращаться к приватным элементам, определённым в его дочерних
    //       модулях.
    //
    //     - из текущего модуля можно обращаться к любому коду, который определён в родительских
    //       модулях или в этом же модуле.

    // Делаем модуль публичным. То что модуль становится публичным не означает, что всё его
    // содержимео тоже автоматически становится публичным.
    pub mod instrument {
        pub fn clarinet() {
            // Для доступа к родительскому модулю при использовании относительных путей можно
            // воспользоваться ключевым словом super(это напоминает доступ к родительской папке в
            // файловой системе через ..):
            super::breath_in();

            // Преимуществом относительных путей является то, что с ними легче проводить
            // перестраивания в иерархии модулей.
        }

        fn foo() {}
    }

    fn breath_in() {
        // Тело функции.
    }
}

//--------------------------------------------------------------------------------
// pub с структурами и перечислениями
//--------------------------------------------------------------------------------

// Если структуру внутри модуля сделать публичной с помощью pub, то это не превращает её поля в
// публичные: для каждого поля нужно отдельно указывать является ли оно публичным:
mod plant {
    pub struct Vegetable {
        pub name: String,
        // Поле id является приватным.
        id: i32,
    }

    impl Vegetable {
        // Без этой ассоциированной функции мы вообще не сумели бы создать экземпляр Vegetable,
        // т.к. при создании экземпляра структуры необходимо явно указывать значения каждого поля,
        // а для поля id мы не можем это сделать, т.к. оно является приватным.
        pub fn new(name: &str) -> Vegetable {
            Vegetable {
                name: String::from(name),
                id: 1,
            }
        }
    }
}

// Для перечислений указание pub перед его определением превращает каждый его вариант в публичный.
mod menu {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

//--------------------------------------------------------------------------------
// Переэкспортирование с помощью pub use
//--------------------------------------------------------------------------------

mod human {
    pub mod head {
        pub fn speak() {
            // Тело функции.
        }
    }
}

mod people {
    // Если бы здесь не было ключевого слова pub, то код в main не смог бы вызвать функцию speak,
    // используя путь people::head::speak или каким-либо другим образом, т.к. то что привносит use
    // по-умолчанию является приватным.
    pub use crate::human::head;

    pub fn talk() {
        head::speak();
    }
}

//--------------------------------------------------------------------------------
// Вложенные пути(nested paths)
//--------------------------------------------------------------------------------

// Для сокращения количества кода при использовании use с большим количеством элементов, у которых
// одинаковые начальные модули, можно воспользоваться вложенными путями. Например, следующий код:
//
//     use std::cmp::Ordering;
//     use std::io;
//
// можно переписать так:
use std::{cmp::Ordering, io};

// Также следующий код:
//
//     use std::io;
//     use std::io::Write;
//
// можно переписать так:
//
//     use std::io{self, Write};

//--------------------------------------------------------------------------------
// *
//--------------------------------------------------------------------------------

// Чтобы привнести все публичные элементы из некоторого пути в текущую область видимости можно
// использовать '*'(glob operator):
use std::collections::*;

// '*' нужно использовать очень осторожно. Часто его используют при тестировании.

fn main() {
    //--------------------------------------------------------------------------------
    // Пути
    //--------------------------------------------------------------------------------

    // Если мы хотим вызвать функцию внутри какого-либо модуля, то нам необходимо знать путь(path)
    // до неё. Существует два вида путей в Rust:
    //
    //     - абсолютный - начинается с корня крейта, используя название пакета, или с литерала
    //       crate.
    //
    //     - относительный - начинается с текущего модуля и использует self, super или
    //       идентификатор в текущем модуле.

    // Пример обращения к функции через путь:

    // Абсолютный путь.
    // Т.к. функция clarinet определена в том же крейте, что и функция main, то мы
    // можем обратиться к ней через абсолютный путь, который начинается с crate.
    // Рассмотрим более подробне почему мы смогли вызвать функцию clarinet(). Модуль sound является
    // приватным, но он определён в том же модуле crate, что и функция main, т.е. находится на
    // одном уровне дерева модулей с main. Поэтому из main можно обращаться к этому модулю. Модуль
    // instrument так же как и функция clarinet является публичным, а раз у нас есть доступ к
    // sound, значит есть доступ и к clarinet.
    crate::sound::instrument::clarinet();

    // Относительный путь.
    // Начинается с модуля sound, который находится на том же уровне в дереве модулей, что и функция
    // main.
    // Мы получили доступ к функции clarinet по тем же причинам, что описаны для случая
    // абсолютного пути, за исключением первого шага - относительные пути не начинаются с crate.
    sound::instrument::clarinet();

    //--------------------------------------------------------------------------------
    // pub с структурами и перечислениями
    //--------------------------------------------------------------------------------

    let mut v = plant::Vegetable::new("squash");
    v.name = String::from("butternut squash");
    println!("{} is delicious", v.name);

    // Будет ошибка компиляции. Поле id является приватным.
    // println!("The ID is {}", v.id);

    // Можно обращаться к вариантам перечисления, т.к. оно является публичным.
    let order1 = menu::Appetizer::Soup;
    let order2 = menu::Appetizer::Salad;

    //--------------------------------------------------------------------------------
    // use
    //--------------------------------------------------------------------------------

    // С помощью ключевого слова use можно сокращать пути для доступа к элементам внутри модулей.
    // Например, следующий use позволяет вместо длинного:
    //
    //     crate::sound::instrument::clarinet();
    //
    // использовать более короткий:
    //
    //     instrument::clarinet();
    use crate::sound::instrument;
    instrument::clarinet();

    // use привносит указанный в нём элемент в область видимости, в которой этот use используется,
    // как будто элемент был определён в этой области видимости. Правила приватности при
    // использовании use сохраняются.

    // use также можно использовать и с относительными путями. Например, use, который приведён
    // выше, можно было написать и так:
    //
    //     use sound::instrument;

    // В Rust принято при использование use с функциями указывать путь до родительского модуля
    // функции и далее обращаться к функции через этот модуль, хотя можно было бы указывать путь
    // прямо до функции:
    //
    //     use crate::sound::instrument::clarinet();
    //
    // и вызывать функции без каких-либо модулей впереди:
    //
    //     clarinet();
    //
    // Для структур, перечислений и других элементов принято указывать весь путь до элемента.
    // Например, можно привнести структуру HashMap в текущую область видимости так:
    use std::collections::HashMap;
    let mut map = HashMap::new();
    map.insert(1, 2);

    // Исключением из этого правила является случай, когда в область видимости привносятся два
    // элемента с одинаковым названием, чего нельзя делать в Rust. Например, следующий код вызовет
    // ошибку компиляции:
    //
    //     use std::fmt::Result;
    //     use std::io::Result;
    //
    // Вместо этого нужно привносить только название модулей:
    //
    //     use std::fmt;
    //     use std::io;
    //
    // Ещё одним решением этой проблемы является использование ключевого слова as для
    // переименования элементов в use:
    use std::fmt::Result;
    use std::io::Result as IoResult;

    // pub use.
    people::talk();
    people::head::speak();

    //--------------------------------------------------------------------------------
    // Внешние крейты
    //--------------------------------------------------------------------------------

    // Для использования внешних крейтов их необходимо объявить в Cargo.toml в разделе
    // [dependencies], а затем использовать use, чтобы привнести нужные нам элементы в область
    // видимости. Так мы делали с крейтом rand в главе 2.0.
}
