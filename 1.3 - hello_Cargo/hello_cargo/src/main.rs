// Cargo - менеджер пакетов и система сборки Rust. Устанавливается вместе с Rust, если
// установку проводить по официальной инструкции. Проверка наличия:
//
//     cargo --version
//
// Cargo решает множество задач: сборка программы, скачивание библиотек, от которых зависит
// программа и их сборка(библиотеки в Rust принято называть зависимостями(dependencies)) и др.
//
// Рекомендуется использовать Cargo при работе с проектами, т.к. очень большая часть проектов
// на Rust создана именно таким образом.
//
// Создать новый проект можно так:
//
//     cargo new hello_cargo
//
// Эта команда приводит к созданию папки hello_cargo. Это одновременно и название нашего проекта.
// Внутри этой папки находится файл Cargo.toml - конфигурация нашего проекта и папка src с
// файлом main.rs. Cargo.toml - это конфигурация нашего проекта. Расширение toml означает
// "Tom's Obvious, Minimal Language" - язык для описания конфигурации чего угодно с уклоном
// на простоту(немного похож на формат ini файлов). Тажке cargo new создаёт сразу же репозитарий
// git с .gitignore(можно не создавать репозитарий, если cargo new выполнить с --vcs none).
// Весь исходит код проекта принято класть в папку src. Корень проекта используют для README,
// лицензии и других параметров, не имеющих отношения к самому коду.
//
// Пакеты кода в Rust принято называть crate'ами. Именно они указываются в разделе [dependecies]
// в файле Cargo.toml.
//
// Для сборки программы с помощью Cargo необходимо выполнить следующую команду из корня проекта,
// т.е. из папки, в которой находится папка src:
//
//     cargo build
//
// На выходе мы получим файл target/debug/hello_cargo. При первом выполнении cargo build также
// создаёт файл Cargo.lock, который хранит точные версии зависимостей нашего проекта. Этот файл
// не нужно править вручную.
// Если нет каких-либо изменений, то Cargo не компилирует файл, что помогает ускорить время
// сборки.
// Собрать и запустить программу одной командой можно так:
//
//     cargo run
//
// Также есть такая команда как
//
//     cargo check
//
// Она позволяет проверить, что проект компилируется, но реально не создаёт запускаемый файл.
// cargo check обычно работает быстрее, чем cargo build.
//
// Когда программа готова, релизную сборку можно собрать так:
//
//     cargo build --release
//
// Эта команда приводит к созданию папки target/release с нашей программой. Релизная сборка
// занимает меньше и работает быстрее отладочной, но для её сборки обычно требуется больше
// времени.

fn main() {
    println!("Hello, Cargo!");
}
