fn main() {
    // В Rust существует понятие владения(ownership) - механизм Rust для управления памятью,
    // выделяемой в куче. Есть правила, которые необходимо знать, для правильного понимания
    // владения:
    //
    //     1. Каждое значение в Rust связано с переменной, которая называется владельцем(owner).
    //     2. В какой-то момент времени может быть только один владелец значения.
    //     3. Когда владелец выходит из области видимости, будет выполнена очистка(drop) значения.

    //--------------------------------------------------------------------------------
    // Область видимости(scope) переменной
    //--------------------------------------------------------------------------------

    // Область видимости переменной - это места в программе, из которых можно обращаться к этой
    // переменной. В Rust(как и во многих других языках) переменная становится видна с момента её
    // определения и до конца блока.

    // Значения типов, которые мы рассматривали до сих пор, хранятся в стеке и поэтому не подходят
    // для иллюстрации работы владения. Поэтому мы далее будем работать с переменными типа String,
    // для значений которых память выделяется в куче:

    let mut s = String::from("owner");
    s.push_str("ship");
    println!("s: {}", s);

    // После вызова метода String::from у операционной системы будет запрошена память, необходимая
    // для хранения строки "foo". Далее в эту память будет помещена строка "foo".
    // Тогда возникает вопрос о том, когда будет освобождена эта память. В Rust эта память будет
    // освобождена, когда переменная, которая владеет этой памятью, выйдет из области видимости,
    // т.е. когда s выйдет из области видимости, т.е. когда мы дойдём до } в конце функции main.
    // Когда переменная выйдет из области видимости Rust вызовит специальную функцию, которую
    // называют drop. В этой функции разработчик типа String может поместить код, который вернёт
    // память системе.

    //--------------------------------------------------------------------------------
    // Move
    //--------------------------------------------------------------------------------

    // Рассмотрим следующий код:
    let x = 0;
    let y = x;
    println!("x,y: {},{}", x, y);

    // Сначала мы создаём переменную x, которая хранит 0, затем переменную y, в которую копируется
    // значение x. Целые типы имеют заранее известный размер, поэтому тут происходит именно
    // копирование, т.е. x и y каждая хранит своё значение.

    // При работе с String ситуация кардинально другая:
    let s1 = String::from("HELLO");
    let s2 = s1;

    // Тип String внутренне состоит из трёх частей:
    //
    //     - указателя на память, в которой фактически хранится строка
    //     - длины строки
    //     - размер строки(сколько памяти система выделила для хранения строки)

    // Эта информация хранится в стеке. Когда мы присваиваем s1 переменной s2 происходит
    // копирование данных строки, т.е. указателя, длины и размера из s1 в s2. Копирования данных,
    // на которые ссылается указатель, не происходит. Т.е. получается, что указатель s1 и указатель
    // s2 ссылаются на один и тот же участок памяти. Как мы говорили выше, когда переменная выходит
    // из области видимости Rust удаляет память, которая была выделена для этой переменной в куче.
    // Следуя этой логике, получается, что память, выделенная для хранения строки, должна быть
    // освобождена дважды, ведь обе переменные s1 и s2 указывают на эту память. Но тут в помощь
    // приходит ещё одна особенность Rust: после того как мы присвоили s1 переменной s2, Rust
    // переводит переменную s1 в ранг невалидных. Поэтому при выходе s1 из области видимости Rust
    // не будет освобождать какую-либо память. Более того, обращение к s1 после присваивания её s2
    // является ошибкой компиляции:

    // Ошибка компиляции.
    // println!("s1: {}", s1);

    // Нет ошибки.
    println!("s2: {}", s2);

    // У присваивания s1 переменной s2 есть и специальное название: перемещение(move).
    // Перемещение можно сравнить с понятием 'shallow copy' из других языков программирования.
    // Также из перемещения следует, что Rust по-умолчанию никогда не делает глубокого копирования.
    // Если же мы хотим специально выполнить глубокое копирование, то можно воспользоваться методом
    // clone:
    let mut s3 = s2.clone();

    // Таким образом мы получили полностью независимую от s2 переменную:
    s3.push_str(", WORLD!");
    println!("s2: {}", s2);
    println!("s3: {}", s3);

    //--------------------------------------------------------------------------------
    // Copy
    //--------------------------------------------------------------------------------

    // Если при присваивании происходит перемещение, то почему работает следующий код:
    let p = 0;
    let q = p;
    println!("p,q: {},{}", p, q);

    // Ведь следуя правилу перемещения, переменная q должна была стать недоступной для
    // использования. Дело в том, что целочисленные типы, размер которых известен во время
    // компиляции, хранятся всегда в стеке.

    // Rust имеет понятие Copy типажа(Copy trait), который можно применить к типам подобным
    // целочисленным, чтобы память для них всегда выделялась в стеке. Если у типа есть типаж Copy,
    // значит старое значение можно использовать после его присваивания. Если у типа есть типаж
    // Drop, то нельзя создавать для него типаж Copy. Следующие типы имеют типаж Copy:
    //
    //    - все целочисленные типы(i32 и т.д.)
    //    - bool
    //    - f32, f64
    //    - char
    //    - кортежи, если все их элементы тоже имеют типаж Copy. Например, (i32, i32) - это Copy, а
    //      (i32, String) нет.
}
