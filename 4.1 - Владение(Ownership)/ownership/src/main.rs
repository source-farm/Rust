fn main() {
    // В Rust существует понятие владения(ownership) - механизм Rust для управления памятью,
    // выделяемой в куче. Есть правила, которые необходимо знать, для правильного понимания
    // владения:
    //
    //     1. Каждое значение в Rust связано с переменной, которая называется владельцем(owner)
    //        этого значения.
    //     2. В какой-то момент времени только одна переменная может владеть значением.
    //     3. Когда владелец выходит из области видимости, будет выполнена очистка(drop) значения.

    //--------------------------------------------------------------------------------
    // Область видимости(scope) переменной
    //--------------------------------------------------------------------------------

    // Область видимости переменной - это места в программе, из которых можно обращаться к этой
    // переменной. В Rust(как и во многих других языках) переменная становится видна с момента её
    // определения и до конца блока.

    // Значения типов, которые мы рассматривали до сих пор, хранятся в стеке и поэтому не подходят
    // для иллюстрации работы владения. Поэтому мы далее будем работать с переменными типа String,
    // для значений которых память выделяется в куче:

    let mut s = String::from("owner");
    s.push_str("ship");
    println!("s: {}", s);

    // После вызова метода String::from у операционной системы будет запрошена память, необходимая
    // для хранения строки "owner". Далее в эту память будет помещена строка "owner".
    // Тогда возникает вопрос о том, когда будет освобождена эта память. В Rust эта память будет
    // освобождена, когда переменная, которая владеет этой памятью, выйдет из области видимости,
    // т.е. когда s выйдет из области видимости, т.е. когда мы дойдём до } в конце функции main.
    // Когда переменная выйдет из области видимости Rust вызовит специальную функцию, которую
    // называют drop. В этой функции разработчик типа String может поместить код, который вернёт
    // память системе.

    //--------------------------------------------------------------------------------
    // Move
    //--------------------------------------------------------------------------------

    // Рассмотрим следующий код:
    let x = 0;
    let y = x;
    println!("x,y: {},{}", x, y);

    // Сначала мы создаём переменную x, которая хранит 0, затем переменную y, в которую копируется
    // значение x. Целые типы имеют заранее известный размер, поэтому тут происходит именно
    // копирование, т.е. x и y каждая хранит своё значение.

    // При работе с String ситуация кардинально другая:
    let s1 = String::from("HELLO");
    let s2 = s1;

    // Тип String внутренне состоит из трёх частей:
    //
    //     - указателя на память, в которой фактически хранится строка
    //     - длины строки
    //     - размер строки(сколько памяти система выделила для хранения строки)

    // Эта информация хранится в стеке. Когда мы присваиваем s1 переменной s2 происходит
    // копирование данных строки, т.е. указателя, длины и размера из s1 в s2. Копирования данных,
    // на которые ссылается указатель, не происходит. Т.е. получается, что указатель s1 и указатель
    // s2 ссылаются на один и тот же участок памяти. Как мы говорили выше, когда переменная выходит
    // из области видимости Rust удаляет память, которая была выделена для этой переменной в куче.
    // Следуя этой логике, получается, что память, выделенная для хранения строки, должна быть
    // освобождена дважды, ведь обе переменные s1 и s2 указывают на эту память. Но тут на помощь
    // приходит ещё одна особенность Rust: после того как мы присвоили s1 переменной s2, Rust
    // переводит переменную s1 в ранг невалидных. Поэтому при выходе s1 из области видимости Rust
    // не будет освобождать какую-либо память. Более того, обращение к s1 после присваивания её s2
    // является ошибкой компиляции:

    // Ошибка компиляции.
    // println!("s1: {}", s1);

    // Нет ошибки.
    println!("s2: {}", s2);

    // У присваивания s1 переменной s2 есть и специальное название: перемещение(move).
    // Перемещение можно сравнить с понятием 'shallow copy' из других языков программирования.
    // Также из перемещения следует, что Rust по-умолчанию никогда не делает глубокого копирования.
    // Если же мы хотим специально выполнить глубокое копирование, то можно воспользоваться методом
    // clone:
    let mut s3 = s2.clone();

    // Таким образом мы получили полностью независимую от s2 переменную:
    s3.push_str(", WORLD!");
    println!("s2: {}", s2);
    println!("s3: {}", s3);

    //--------------------------------------------------------------------------------
    // Copy
    //--------------------------------------------------------------------------------

    // Если при присваивании происходит перемещение, то почему работает следующий код:
    let p = 0;
    let q = p;
    println!("p,q: {},{}", p, q);

    // Ведь следуя правилу перемещения, переменная q должна была стать недоступной для
    // использования. Дело в том, что целочисленные типы, размер которых известен во время
    // компиляции, хранятся всегда в стеке.

    // Rust имеет понятие Copy типажа(Copy trait), который можно применить к типам подобным
    // целочисленным, чтобы память для них всегда выделялась в стеке. Если у типа есть типаж Copy,
    // значит старое значение можно использовать после его присваивания. Если у типа есть типаж
    // Drop, то нельзя создавать для него типаж Copy. Следующие типы имеют типаж Copy:
    //
    //    - все целочисленные типы(i32 и т.д.)
    //    - bool
    //    - f32, f64
    //    - char
    //    - кортежи, если все их элементы тоже имеют типаж Copy. Например, (i32, i32) - это Copy, а
    //      (i32, String) нет.

    //--------------------------------------------------------------------------------
    // Владение и функции
    //--------------------------------------------------------------------------------

    // При передаче аргументов в функцию происходит то же самое, что и при присваивании: если у
    // типа есть типаж Copy, то значение будет скопировано, а иначе будет выполнено
    // перемещение(move).
    let msg = String::from("GOOD");
    // Здесь происходит перемещение. После вызова функции take_ownership попытка использовать
    // переменную msg вызовет ошибку компиляции, т.к. Rust обозначит её как невалидную.
    take_ownership(msg);
    // Ошибка компиляции.
    // println!("msg: {}", msg);

    let k = 29;
    // Здесь будет выполнено копирование. Поэтому после вызова makes_copy можно и дальше
    // пользоваться переменной k.
    makes_copy(k);
    println!("k: {}", k);

    //--------------------------------------------------------------------------------
    // Владение и возвращаемые значения
    //--------------------------------------------------------------------------------

    // Возвращаемые значения тоже следуют либо правилу копирования или перемещения в зависимости
    // от наличия у типа типажа Copy.

    // m1 становится владельцем строки, которую возвращает функция gives_ownership.
    let m1 = gives_ownership();
    println!("m1: {}", m1);

    let m2 = String::from("gift");
    // После вызова takes_and_gives_back переменной m2 уже нельзя пользоваться, т.к. она была
    // перемещена, а следовательно стала невалидной.
    let m3 = takes_and_gives_back(m2);
    println!("m3: {}", m3);
    // Ошибка компиляции, т.к. m2 было перемещено.
    // println!("m2: {}", m2);

    // Что делать, если мы хотели просто передать значение в функцию без необходимости перемещения?
    // Из-за механизма владения приходится возвращать переданную в функцию строку, т.к. по-другому
    // мы потеряем значение. Если же нужно возвращать ещё дополнительно какое-либо значение, то
    // Rust позволяет возвращать из функции кортеж:
    let m4 = String::from("smile");
    let (m5, len) = calculate_length(m4);
    println!("m5: {}, len: {}", m5, len);

    // Такой синтаксис является довольно неудобным. К счастью в Rust есть так называемые ссылки,
    // которые позволяют решить эту проблему. Они будут рассмотрены в следующей главе.
}

fn take_ownership(some_string: String) {
    println!("some_string: {}", some_string);
} // some_string выходит из области видимости, поэтому будет вызван 'drop' для освобождения памяти.

fn makes_copy(some_integer: i32) {
    println!("some_integer: {}", some_integer);
}

fn gives_ownership() -> String {
    let some_string = String::from("fly");
    // Т.к. после some_string нет ';' мы получаем выражение, а последнее выражение функции как мы
    // знаем является возвращаемым значением функции. При возврате будет выполнено перемещение.
    some_string
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}
