fn main() {
    //--------------------------------------------------------------------------------
    // Ссылки и заимствование
    //--------------------------------------------------------------------------------

    let s1 = String::from("HELLO");
    // Если параметром функции является ссылка, то для передачи аргумента необходимо ставить перед
    // аргументом знак '&'. Этот знак позволяет нам получить ссылку на значение, которое хранит
    // аргумент. Перемещения(move) тут не происходит. Именно для этого и используются ссылки.
    let len = calculate_length(&s1);
    println!("s1: {}, len: {}", s1, len);

    // Наличие у функции параметра ссылки в Rust называют заимствованием(borrowing).

    //--------------------------------------------------------------------------------
    // Изменяемые ссылки
    //--------------------------------------------------------------------------------

    // Так же как и переменные бывают неизменяемые(по-умолчанию) и изменяемые(mutable) ссылки.
    let mut s2 = String::from("good");
    // Передача изменяемой ссылки.
    change(&mut s2);
    println!("s2: {}", s2);

    // Также есть некоторые особенности работы ссылок в Rust. Одной из них является то, что нельзя
    // в одной области видимости иметь больше одной изменяемой ссылки:
    let mut s3 = String::from("bear");
    let r1 = &mut s3;
    println!("r1: {}", r1);
    // Следующий код вызовет ошибку компиляции.
    // let r2 = &mut s3;
    // println!("r1: {}, r2: {}", r1, r2);

    // Благодаря этому на этапе компиляции можно предотвратить гонки данных(data race). Гонки
    // данных - это частный случай условий гонок(race condition) и возникают, если выполнены
    // следующие 3 условия:
    //
    //    - 2 или более указателя получают доступ к одним и тем же данным
    //    - по крайней мере один указатель изменяет данные
    //    - не используется никакого механизма синхронизации доступа к данным
    //
    // Ошибки гонок чрезвычайно сложно обнаружить. Поэтому то, что они могут быть перехвачены на
    // этапе компиляции является преимуществом Rust, хотя новичкам это может усложнить сборку
    // проекта.

    // Из этой же оперы является и следующие ограничение ссылок в Rust: нельзя в некоторой области
    // видимости создавать изменяемые ссылки, если в ней уже есть неизменяемые:
    {
        let mut s = String::from("zebra");
        s.push_str(" and tiger");
        // Наличие нескольких неизменяемых ссылок в одной области видимости не является ошибкой.
        let r1 = &s; // OK
        let r2 = &s; // OK
        println!("r1: {}, r2: {}", r1, r2);

        // Следующий код вызове ошибку.
        // let r3 = &mut s; // NOT OK
        // println!("r1: {}, r2: {}, r3: {}", r1, r2, r3);
    }
}

// Чтобы передать в функцию значение без перемещения нужно, чтобы параметр функции был ссылкой. Для
// этого нужно ставить знак '&' перед типом параметра.
fn calculate_length(s: &String) -> usize {
    // Будет ошибка компиляции, т.к. по-умолчанию ссылки являются неизменяемыми:
    s.len()
}

fn change(some_string: &mut String) {
    some_string.push_str(" job");
}

//--------------------------------------------------------------------------------
// Висячие ссылки
//--------------------------------------------------------------------------------

/*

fn dangle() -> &String {
    let s = String::from("New");
    // В Rust компилятор гарантирует, что у нас никогда не окажется висячих ссылок(dangling
    // references). Т.е. если есть ссылка, то ей можно пользоваться всегда, а не проводить какие-то
    // проверки, что она куда-то указывает. После выхода из этой функции будет вызван drop для
    // s, что приведёт к очистке памяти, выделенной для хранения строки. Поэтому ссылаться дальше
    // на это значение нельзя.
    &s
}

*/
