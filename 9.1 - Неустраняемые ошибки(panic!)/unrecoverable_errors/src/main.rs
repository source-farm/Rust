fn main() {
    // Иногда в коде случается что-то совсем плохое, что остаётся только остановить выполнение
    // программы. Для этого в Rust есть макрос panic!. При вызове этого макроса программа выводит
    // сообщение об ошибке, раскручивает и очищает стек и выходит. Можно также не выполнять
    // раскручивание стека, а сразу произвести выход, если добавить следующее в Cargo.toml:
    //
    //     [profile.release]
    //     panic = 'abort'
    //
    // Благодаря этой настройке релизная версия программы будет сразу выходить при панике. Также
    // эта настройка приводит к сокращению размера программы.

    // Явный вызов паники.
    // panic!("Crash and burn");

    // Ещё одна паника.
    // let v = vec![1, 2, 3];
    // v[99];

    // Если идёт сборка не релизной версии(т.е. без --release в cargo build), то программа
    // собирается так, чтобы можно было увидеть весь стек вызовов в момент происхождения паники.
    // Для этого нужно установить переменную окружения RUST_BACKTRACE не равной 0(export RUST_BACKTRACE=1).
    // В самом верху вывода стека вызовов идут более последние вызовы функций, чем ниже, тем более
    // ранние вызовы. Наша задача заключается в том, что найти в этом стеке файлы с кодом, который
    // писали мы и исправить ошибку.
}
