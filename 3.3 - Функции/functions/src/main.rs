fn main() {
    // Функция может быть определена в любом месте программы, т.е. необъязательно определять её
    // перед использованием.
    another_function();

    foo(0, 0);

    //--------------------------------------------------------------------------------
    // Инструкции и выражения
    //--------------------------------------------------------------------------------

    // В Rust код внутри функций делится на инструкции(statements) и выражения(expressions) и
    // необходимо чётко понять различие между ними:
    //
    //     - инструкции - это код, который выполняет некоторые действия, но не возвращает
    //                    значение
    //
    //     - выражение - это код, который возвращает значение.
    //
    // Например, объявление переменной как "let x = 6;" является инструкцией.Поэтому следующий код
    // выдаст ошибку компиляции:

    // Ошибка: let y = 0 ничего не возвращает.
    // let x = (let y = 0);

    // Инструкцией является также и определение функции.

    // Выражения возвращают значение и из них в основном и состоит код. Например, простое
    // вычисление как 5 + 6 является выражением, которое возвращает 11. Выражения могут быть
    // частью инструкций. Например, в инструкции "let x = 13;" 13 является выражением, которое
    // сводится(evaluates) к 13. Вызов функции или макроса является выражением. Блоки, которые
    // используются для новых областей видимости(scope) тоже являются выражениями:
    let x = 0;
    let y = {
        let x = 3;
        // Здесь следует обратить внимание на отсутствие ';' в конце x + 1. Выражения не имеют в
        // конце ';'. Именно из-за этого блок и превращается в выражение. Если бы там был знак ';',
        // мы получили бы инструкцию.
        x + 1
    };
    println!("x,y: {},{}", x, y);

    let n = five();
    println!("n: {}", n);
}

// В Rust принято использовать змеиный регистр: все буквы идентификатора находятся в нижнем
// регистре, слова разделяются с помощью '_'.
fn another_function() {
    println!("Another function.");
}

// Функция с параметрами. Фактически передаваемое значение принято называть аргументом.
fn foo(x: i32, y: i32) {
    println!("x,y: {},{}", x, y);
}

// Функции могут возвращать значения. Тип возвращаемых значений указывается после знака '->'.
// В Rust возвращаемое значение функции - это то же самое, что и последнее выражение в теле
// этой функции. Можно конечно завершить выполнение функции вызовом return с некоторым значением
// в середине функции.
fn five() -> i32 {
    // Как мы уже говорили, числа сами по себе являются выражениями.
    // Если после 5 поставить ';', то будет ошибка компиляции.
    5
}
